# 조명 구현 가이드

이 문서는 `gaym` 프로젝트의 현재 조명 시스템 구현 방식, 데이터 흐름, 그리고 사용/수정 방법에 대해 상세히 설명합니다.

## 1. 핵심 개념

`gaym` 프로젝트는 **퐁(Phong) 조명 모델**을 기반으로 조명을 구현합니다. 이 모델은 물체의 표면이 빛과 상호작용하는 방식을 시뮬레이션하여 현실적인 외관을 만듭니다. 퐁 모델은 주로 세 가지 구성 요소로 이루어집니다:

*   **주변광 (Ambient Light):** 모든 방향에서 균일하게 비추는 빛을 시뮬레이션하여 그림자 영역이 완전히 어두워지는 것을 방지합니다.
*   **확산광 (Diffuse Light):** 광원으로부터 직접 오는 빛이 물체 표면에 부딪혀 모든 방향으로 고르게 반사되는 것을 시뮬레이션합니다. 물체의 색상(알베도)에 영향을 받습니다.
*   **반사광 (Specular Light):** 광원으로부터 오는 빛이 물체 표면에서 거울처럼 반사되어 하이라이트를 생성하는 것을 시뮬레이션합니다. 물체의 광택(shininess)에 영향을 받습니다.

현재 프로젝트는 다음 세 가지 유형의 광원을 지원합니다:
*   **방향광 (Directional Light):** 태양과 같이 모든 물체에 평행하게 비추는 광원입니다. 위치는 중요하지 않고 방향만 중요합니다.
*   **점광원 (Point Light):** 전구와 같이 한 지점에서 모든 방향으로 빛을 방출하는 광원입니다. 위치와 범위가 중요합니다.
*   **전역 주변광 (Global Ambient Light):** 씬 전체에 적용되는 균일한 주변광입니다.

## 2. 데이터 흐름 (C++에서 HLSL로)

조명 관련 데이터는 크게 **객체별 데이터 (Per-Object Data)**와 **패스별 데이터 (Per-Pass Data)**로 나뉘어 GPU로 전달됩니다.

### 2.1. 객체별 데이터 (`cbGameObject`)

객체별 데이터는 각 `GameObject`의 고유한 속성(예: 월드 변환, 재질)을 포함하며, 셰이더의 `b0` 레지스터에 바인딩됩니다.

*   **`MATERIAL` 구조체 (C++ 및 HLSL):**
    *   `XMFLOAT4 m_cAmbient;` (주변광 색상)
    *   `XMFLOAT4 m_cDiffuse;` (확산광 색상)
    *   `XMFLOAT4 m_cSpecular;` (반사광 색상, `a` 컴포넌트에 광택(power) 값 포함)
    *   `XMFLOAT4 m_cEmissive;` (방출광 색상)
    *   이 구조체는 `GameObject.h`에 정의되어 있으며, 셰이더의 `ObjectConstants` 내부에 포함되어 사용됩니다.

*   **`ObjectConstants` 구조체 (C++ 및 HLSL):**
    *   `XMFLOAT4X4 m_xmf4x4World;` (객체의 월드 변환 행렬)
    *   `UINT m_nMaterialIndex = 0;` (재질 인덱스, 현재는 `mMaterial`이 직접 사용되므로 역할이 모호함)
    *   `MATERIAL mMaterial;` (위에서 설명한 재질 속성)
    *   이 구조체는 `GameObject.h`에 정의되어 있으며, `cbGameObject` 상수 버퍼의 레이아웃을 정의합니다.

*   **`GameObject`의 역할:**
    *   각 `GameObject`는 `m_Material` 멤버 변수에 자신의 재질 속성을 저장합니다.
    *   `GameObject::SetMaterial(const MATERIAL& material)` 메서드를 통해 객체의 재질을 설정할 수 있습니다.
    *   `GameObject::Update(float deltaTime)` 메서드 내부에서 `m_Material`과 객체의 월드 행렬이 `m_pcbMappedGameObject`가 가리키는 `ObjectConstants` 구조체로 복사됩니다. 이 `ObjectConstants`는 GPU에 매핑된 상수 버퍼입니다.
    *   `GameObject::CreateConstantBuffer`는 `ObjectConstants`를 위한 상수 버퍼를 생성하고 CPU/GPU 디스크립터 핸들을 설정합니다.

*   **`RenderComponent`의 역할:**
    *   `RenderComponent::Render(ID3D12GraphicsCommandList* pCommandList)` 메서드 내부에서 `m_pOwner->GetGpuDescriptorHandle()`을 사용하여 해당 `GameObject`의 `cbGameObject` 디스크립터 테이블을 루트 파라미터 0에 바인딩합니다.

### 2.2. 패스별 데이터 (`cbPass`)

패스별 데이터는 씬 전체에 공통적으로 적용되는 정보(예: 카메라 시점, 광원 매개변수)를 포함하며, 셰이더의 `b1` 레지스터에 바인딩됩니다.

*   **`PassConstants` 구조체 (C++ 및 HLSL):**
    *   `XMFLOAT4X4 m_xmf4x4ViewProj;` (카메라의 뷰-투영 행렬)
    *   `XMFLOAT4 m_xmf4LightColor;` (방향광 색상)
    *   `XMFLOAT3 m_xmf3LightDirection;` (방향광 방향)
    *   `XMFLOAT4 m_xmf4PointLightColor;` (점광원 색상)
    *   `XMFLOAT3 m_xmf3PointLightPosition;` (점광원 위치)
    *   `float m_fPointLightRange;` (점광원 범위)
    *   `XMFLOAT4 m_xmf4AmbientLight;` (전역 주변광 색상)
    *   `XMFLOAT3 m_xmf3CameraPosition;` (카메라의 월드 위치)
    *   이 구조체는 `Scene.h`에 정의되어 있으며, `cbPass` 상수 버퍼의 레이아웃을 정의합니다.

*   **`Scene`의 역할:**
    *   `Scene` 클래스는 `m_pd3dcbPass` 멤버 변수로 `PassConstants`를 위한 상수 버퍼를 관리합니다.
    *   `Scene::Init` 메서드에서 `m_pd3dcbPass` 상수 버퍼를 생성하고 `m_pcbMappedPass`에 매핑합니다.
    *   `Scene::Update(float deltaTime, InputSystem* pInputSystem)` 메서드 내부에서 `m_pcbMappedPass`가 가리키는 `PassConstants` 구조체에 카메라의 뷰-투영 행렬, 광원 매개변수(현재 하드코딩됨), 카메라의 월드 위치를 채워 넣습니다.
    *   `Scene::GetPassCBVAddress()`는 `cbPass`의 GPU 가상 주소를 반환합니다.

*   **`Shader`의 역할:**
    *   `Shader::Render(ID3D12GraphicsCommandList* pCommandList, D3D12_GPU_VIRTUAL_ADDRESS cbvPassAddress)` 메서드는 `Scene`으로부터 `cbPass`의 GPU 가상 주소를 받아 루트 파라미터 1에 바인딩합니다.

## 3. HLSL (`shaders.hlsl`)

`shaders.hlsl` 파일은 GPU에서 실행되는 셰이더 코드를 포함합니다.

*   **`cbuffer` 정의:**
    ```hlsl
    cbuffer cbGameObject : register(b0)
    {
        float4x4 g_xmf4x4World;
        uint g_nMaterialIndex;
        float3 pad1;
        MATERIAL g_Material;
    };

    cbuffer cbPass : register(b1)
    {
        float4x4 g_xmf4x4ViewProj;
        float4 g_LightColor;
        float3 g_LightDirection;
        float g_fPad0;
        float4 g_PointLightColor;
        float3 g_PointLightPosition;
        float g_fPad1;
        float g_fPointLightRange;
        float3 g_fPad2; // Adjusted padding for alignment
        float4 g_AmbientLight;
        float3 g_CameraPosition;
        float g_fPadCam;
    };
    ```
    이 정의들은 C++의 `ObjectConstants` 및 `PassConstants` 구조체와 일치해야 합니다.

*   **픽셀 셰이더 (`PS` 함수):**
    `PS` 함수는 각 픽셀에 대해 조명 계산을 수행합니다.
    1.  `g_Material`에서 물체의 재질 속성을 가져옵니다.
    2.  `g_AmbientLight`와 `g_Material.m_cAmbient`를 사용하여 주변광을 계산합니다.
    3.  `g_LightDirection`, `g_LightColor`, `g_Material.m_cDiffuse`를 사용하여 방향광의 확산 및 반사 성분을 계산합니다.
    4.  `g_PointLightPosition`, `g_PointLightColor`, `g_PointLightRange`, `g_Material.m_cDiffuse`를 사용하여 점광원의 확산 및 반사 성분을 계산합니다.
    5.  계산된 모든 조명 성분을 합산하여 최종 픽셀 색상을 결정합니다.

## 4. 사용/수정 방법

### 4.1. 객체 재질 변경

각 `GameObject`의 재질은 `GameObject::SetMaterial` 메서드를 통해 설정할 수 있습니다.
```cpp
// 예시: 특정 GameObject의 재질 변경
GameObject* pMyObject = ...; // GameObject 인스턴스 가져오기
MATERIAL newMaterial;
newMaterial.m_cAmbient = XMFLOAT4(0.2f, 0.0f, 0.0f, 1.0f); // 어두운 빨간색 주변광
newMaterial.m_cDiffuse = XMFLOAT4(0.8f, 0.0f, 0.0f, 1.0f); // 빨간색 확산광
newMaterial.m_cSpecular = XMFLOAT4(1.0f, 1.0f, 1.0f, 30.0f); // 강한 흰색 반사광 (광택 30)
newMaterial.m_cEmissive = XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f); // 방출광 없음
pMyObject->SetMaterial(newMaterial);
```

### 4.2. 광원 매개변수 수정

현재 광원 매개변수는 `Scene::Update` 메서드 내에 하드코딩되어 있습니다. 이 값들을 직접 수정하여 씬의 조명 환경을 변경할 수 있습니다.

```cpp
// Scene::Update 메서드 내에서 다음 값들을 수정합니다.
// 방향광 (Directional Light)
m_pcbMappedPass->m_xmf4LightColor = XMFLOAT4(0.9f, 0.85f, 0.75f, 1.0f); // 색상 (예: 따뜻한 흰색)
XMVECTOR lightDir = XMVector3Normalize(XMVectorSet(-0.5f, -1.0f, 0.5f, 0.0f)); // 방향 (예: 태양 각도)
XMStoreFloat3(&m_pcbMappedPass->m_xmf3LightDirection, lightDir);

// 점광원 (Point Light)
m_pcbMappedPass->m_xmf4PointLightColor = XMFLOAT4(0.7f, 0.5f, 0.3f, 1.0f); // 색상 (예: 따뜻한 주황색)
m_pcbMappedPass->m_xmf3PointLightPosition = XMFLOAT3(10.0f, 5.0f, -10.0f); // 위치
m_pcbMappedPass->m_fPointLightRange = 50.0f; // 범위

// 전역 주변광 (Global Ambient Light)
m_pcbMappedPass->m_xmf4AmbientLight = XMFLOAT4(0.05f, 0.07f, 0.1f, 1.0f); // 색상 (예: 어두운 푸른색)
```

### 4.3. 광원 추가 (향후 확장)

현재 구조는 각 유형별로 단일 광원만 처리하도록 설계되어 있습니다. 여러 개의 광원을 추가하려면 다음을 수정해야 합니다:

1.  **`PassConstants` 구조체 (HLSL 및 C++):** 추가할 광원의 매개변수(색상, 위치, 방향, 범위 등)를 포함하도록 확장해야 합니다. 배열을 사용하거나 여러 개의 개별 광원 변수를 선언할 수 있습니다.
2.  **`Scene::Update` (C++):** 확장된 `PassConstants` 구조체에 맞게 새로운 광원 데이터를 채워 넣는 로직을 추가해야 합니다.
3.  **`shaders.hlsl` (HLSL):** 픽셀 셰이더(`PS` 함수)에서 추가된 광원들에 대한 조명 계산 로직을 구현하고, 모든 광원의 기여도를 합산해야 합니다.

## 5. 현재 제한 사항

*   **하드코딩된 광원 매개변수:** `Scene::Update`에 광원 매개변수가 직접 하드코딩되어 있어, 런타임에 동적으로 광원을 추가, 제거, 수정하기 어렵습니다.
*   **광원 객체 부재:** 광원을 추상화하는 별도의 C++ 클래스(예: `Light` 기본 클래스 및 `DirectionalLight`, `PointLight` 파생 클래스)가 없어, 광원 관리가 `Scene` 클래스에 직접적으로 묶여 있습니다.

이러한 제한 사항들은 향후 프로젝트 확장 시 개선될 수 있습니다.
